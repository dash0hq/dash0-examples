mode: daemonset
image:
  repository: otel/opentelemetry-collector-contrib

resources:
  limits:
    memory: 512Mi
  requests:
    memory: 256Mi

extraEnvs:
  - name: DASH0_AUTH_TOKEN
    valueFrom:
      secretKeyRef:
        name: dash0-secrets
        key: dash0-authorization-token
  - name: DASH0_ENDPOINT_OTLP_GRPC_HOSTNAME
    valueFrom:
      secretKeyRef:
        name: dash0-secrets
        key: dash0-grpc-hostname
  - name: DASH0_ENDPOINT_OTLP_GRPC_PORT
    valueFrom:
      secretKeyRef:
        name: dash0-secrets
        key: dash0-grpc-port

clusterRole:
  create: true
  rules:
    - apiGroups: [""]
      resources: ["nodes/proxy"]
      verbs: ["get"]

tolerations:
  - key: node-role.kubernetes.io/control-plane
    operator: Exists
    effect: NoSchedule

presets:
  logsCollection:
    enabled: true
  kubernetesAttributes:
    enabled: true
  kubeletMetrics:
    enabled: true
  hostMetrics:
    enabled: true

config:
  processors:
    # First transform: Parse Emissary logs and extract attributes (only for Emissary pods)
    transform/emissary-parse:
      log_statements:
        - context: log
          statements:
            # Only process logs from Emissary pods with JSON structure
            - set(attributes["parsed_body"], ParseJSON(body)) where IsString(body) and IsMatch(body, "^\\{.*method.*\\}$") and resource.attributes["k8s.deployment.name"] == "emissary-ingress"
            # Set log fields as attributes using exact field names from log message (matching Contour format)
            - set(attributes["@timestamp"], attributes["parsed_body"]["@timestamp"]) where attributes["parsed_body"]["@timestamp"] != nil
            - set(attributes["authority"], attributes["parsed_body"]["authority"]) where attributes["parsed_body"]["authority"] != nil
            - set(attributes["bytes_received"], attributes["parsed_body"]["bytes_received"]) where attributes["parsed_body"]["bytes_received"] != nil
            - set(attributes["bytes_sent"], attributes["parsed_body"]["bytes_sent"]) where attributes["parsed_body"]["bytes_sent"] != nil
            - set(attributes["duration"], attributes["parsed_body"]["duration"]) where attributes["parsed_body"]["duration"] != nil
            - set(attributes["method"], attributes["parsed_body"]["method"]) where attributes["parsed_body"]["method"] != nil
            - set(attributes["path"], attributes["parsed_body"]["path"]) where attributes["parsed_body"]["path"] != nil
            - set(attributes["protocol"], attributes["parsed_body"]["protocol"]) where attributes["parsed_body"]["protocol"] != nil
            - set(attributes["request_id"], attributes["parsed_body"]["request_id"]) where attributes["parsed_body"]["request_id"] != nil
            - set(attributes["response_code"], attributes["parsed_body"]["response_code"]) where attributes["parsed_body"]["response_code"] != nil
            - set(attributes["response_flags"], attributes["parsed_body"]["response_flags"]) where attributes["parsed_body"]["response_flags"] != nil
            - set(attributes["upstream_cluster"], attributes["parsed_body"]["upstream_cluster"]) where attributes["parsed_body"]["upstream_cluster"] != nil
            - set(attributes["upstream_host"], attributes["parsed_body"]["upstream_host"]) where attributes["parsed_body"]["upstream_host"] != nil
            - set(attributes["upstream_service_time"], attributes["parsed_body"]["upstream_service_time"]) where attributes["parsed_body"]["upstream_service_time"] != nil
            - set(attributes["user_agent"], attributes["parsed_body"]["user_agent"]) where attributes["parsed_body"]["user_agent"] != nil
            - set(attributes["x_forwarded_for"], attributes["parsed_body"]["x_forwarded_for"]) where attributes["parsed_body"]["x_forwarded_for"] != nil
            # Store traceparent for next transform step
            - set(attributes["traceparent"], attributes["parsed_body"]["traceparent"]) where attributes["parsed_body"]["traceparent"] != nil and attributes["parsed_body"]["traceparent"] != "-"
            # Update the body to use the parsed content
            - set(body, attributes["parsed_body"]) where attributes["parsed_body"] != nil
            # Clean up intermediate parsing attributes
            - delete_key(attributes, "parsed_body") where attributes["parsed_body"] != nil

    # Second transform: Extract trace correlation from traceparent (only for logs that have it)
    transform/trace-extract:
      log_statements:
        - context: log
          statements:
            # Extract trace_id and span_id from traceparent header (W3C format: 00-{trace_id}-{span_id}-{flags})
            - set(trace_id.string, Substring(attributes["traceparent"], 3, 32)) where attributes["traceparent"] != nil and IsMatch(attributes["traceparent"], "^00-[a-f0-9]{32}-[a-f0-9]{16}-[0-9a-f]{2}$")
            - set(span_id.string, Substring(attributes["traceparent"], 36, 16)) where attributes["traceparent"] != nil and IsMatch(attributes["traceparent"], "^00-[a-f0-9]{32}-[a-f0-9]{16}-[0-9a-f]{2}$")

    k8sattributes:
      extract:
        metadata:
          - k8s.namespace.name
          - k8s.deployment.name
          - k8s.statefulset.name
          - k8s.daemonset.name
          - k8s.cronjob.name
          - k8s.job.name
          - k8s.node.name
          - k8s.pod.name
          - k8s.pod.uid
          - k8s.pod.start_time
        # Disabled labels/annotations to avoid OpenSearch mapping conflicts
        # labels:
        #   - from: pod
        #     key_regex: (.*)
        #     tag_name: k8s.pod.label.$${1}
        # annotations:
        #   - from: pod
        #     key_regex: (.*)
        #     tag_name: k8s.pod.annotation.$${1}
      filter:
        node_from_env_var: K8S_NODE_NAME
      passthrough: false
      pod_association:
        - sources:
          - from: resource_attribute
            name: k8s.pod.ip
        - sources:
          - from: resource_attribute
            name: k8s.pod.uid
        - sources:
          - from: connection

  receivers:
    kubeletstats:
      insecure_skip_verify: true # For testing purposes. Remove for production.

  exporters:
    otlp/dash0:
      auth:
        authenticator: bearertokenauth/dash0
      endpoint: ${env:DASH0_ENDPOINT_OTLP_GRPC_HOSTNAME}:${env:DASH0_ENDPOINT_OTLP_GRPC_PORT}

    # OpenSearch exporter (local logs)
    opensearch/log:
      http:
        endpoint: https://opensearch-cluster-master.default.svc.cluster.local:9200
        auth:
          authenticator: basicauth/opensearch
        tls:
          insecure_skip_verify: true
      logs_index: otel-logs

  extensions:
    bearertokenauth/dash0:
      scheme: Bearer
      token: ${env:DASH0_AUTH_TOKEN}

    basicauth/opensearch:
      client_auth:
        username: admin
        password: "SecureP@ssw0rd123"

  service:
    extensions:
      - bearertokenauth/dash0
      - basicauth/opensearch
      - health_check
    pipelines:
      logs:
        processors:
          - k8sattributes
          - transform/emissary-parse
          - transform/trace-extract
          - memory_limiter
          - batch
        exporters:
          - otlp/dash0
          - opensearch/log
      metrics:
        exporters:
          - otlp/dash0
      traces:
        exporters:
          - otlp/dash0